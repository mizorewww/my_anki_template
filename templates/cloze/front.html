<!-- Anki Cloze Modern Template - Front Side -->

<!-- KaTeX CSS -->
<link rel="stylesheet" href="_katex.min.css">

<!-- Highlight.js CSS (根据主题自动选择) -->
<link id="hljs-light" rel="stylesheet" href="_github.min.css" media="(prefers-color-scheme: light)">
<link id="hljs-dark" rel="stylesheet" href="_github-dark.min.css" media="(prefers-color-scheme: dark)">

<div class="content-wrapper">
    <div id="rendered-content"></div>
</div>

<!-- 原始内容存储 (使用 HTML 注释避免反引号问题) -->
<div id="raw-content" style="display:none;">{{cloze:Text}}</div>

<script src="_marked.min.js"></script>
<script src="_katex.min.js"></script>
<script src="_highlight.min.js"></script>

<script>
    (function () {
        // =====================================================
        // 五阶段令牌化渲染器 - 解决 Anki 标签与 Markdown/LaTeX 冲突
        // =====================================================

        // 从隐藏 div 获取内容，避免模板字符串反引号问题
        const rawContent = document.getElementById('raw-content').innerHTML;

        // 检查依赖是否加载
        if (typeof marked === 'undefined' || typeof katex === 'undefined' || typeof hljs === 'undefined') {
            document.getElementById('rendered-content').innerHTML =
                '<p style="color: red;">错误: 库文件未加载。请运行 python anki_connect.py 同步媒体文件。</p>' +
                '<p>原始内容:</p><pre>' + rawContent + '</pre>';
            return;
        }

        // 阶段1: 保护 Anki 填空标签
        const clozeTokens = [];
        let tokenized = rawContent.replace(/<span class="cloze[^"]*"[^>]*>[\s\S]*?<\/span>/gi, function (match) {
            const token = '%%CLOZE_' + clozeTokens.length + '%%';
            clozeTokens.push(match);
            return token;
        });

        // 阶段2: 保护 LaTeX 公式 ($$...$$ 和 $...$)
        const latexTokens = [];
        // 块级公式 $$...$$
        tokenized = tokenized.replace(/\$\$([\s\S]*?)\$\$/g, function (match, formula) {
            const token = '%%LATEX_BLOCK_' + latexTokens.length + '%%';
            latexTokens.push({ type: 'block', formula: formula });
            return token;
        });
        // 行内公式 $...$
        tokenized = tokenized.replace(/\$([^\$\n]+?)\$/g, function (match, formula) {
            const token = '%%LATEX_INLINE_' + latexTokens.length + '%%';
            latexTokens.push({ type: 'inline', formula: formula });
            return token;
        });

        // 阶段3: Markdown 渲染
        marked.setOptions({
            breaks: true,
            gfm: true
        });

        let rendered = marked.parse(tokenized);

        // 阶段4: 还原 LaTeX 并渲染
        rendered = rendered.replace(/%%LATEX_BLOCK_(\d+)%%/g, function (match, index) {
            const item = latexTokens[parseInt(index)];
            try {
                return katex.renderToString(item.formula, {
                    displayMode: true,
                    throwOnError: false,
                    output: 'html'
                });
            } catch (e) {
                return '<span class="katex-error">' + item.formula + '</span>';
            }
        });

        rendered = rendered.replace(/%%LATEX_INLINE_(\d+)%%/g, function (match, index) {
            const item = latexTokens[parseInt(index)];
            try {
                return katex.renderToString(item.formula, {
                    displayMode: false,
                    throwOnError: false,
                    output: 'html'
                });
            } catch (e) {
                return '<span class="katex-error">' + item.formula + '</span>';
            }
        });

        // 阶段5: 还原 Anki 填空标签
        rendered = rendered.replace(/%%CLOZE_(\d+)%%/g, function (match, index) {
            return clozeTokens[parseInt(index)];
        });

        // 渲染到页面
        document.getElementById('rendered-content').innerHTML = rendered;

        // 对代码块进行高亮
        document.querySelectorAll('pre code').forEach(function (block) {
            hljs.highlightElement(block);
        });
    })();
</script>